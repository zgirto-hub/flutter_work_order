import 'package:flutter/material.dart';
import '../models/work_order.dart';
import '../services/work_order_service.dart';
import '../models/employee.dart';
import '../services/employee_service.dart';

class AddWorkOrderScreen extends StatefulWidget {
  final WorkOrder? workOrder;
  final String? autoGeneratedJobNo;

  const AddWorkOrderScreen({
    super.key,
    this.workOrder,
    this.autoGeneratedJobNo,
  });

  @override
  State<AddWorkOrderScreen> createState() => _AddWorkOrderScreenState();
}

class _AddWorkOrderScreenState extends State<AddWorkOrderScreen> {
  final EmployeeService _employeeService = EmployeeService();

  List<Employee> _employees = [];
  List<String> _selectedEmployeeIds = [];
  final WorkOrderService _service = WorkOrderService();
  final _formKey = GlobalKey<FormState>();

  final TextEditingController jobNoController = TextEditingController();
  final TextEditingController clientController = TextEditingController();
  final TextEditingController descriptionController = TextEditingController();
  final TextEditingController locationController = TextEditingController();

  String selectedStatus = "Pending";
  String selectedType = "Technical";

  @override
  void initState() {
    super.initState();
    _loadEmployees();
    if (widget.workOrder != null) {
      // EDIT MODE
      jobNoController.text = widget.workOrder!.jobNo;
      clientController.text = widget.workOrder!.Title;
      descriptionController.text = widget.workOrder!.description;
      locationController.text = widget.workOrder!.location;

      final allowedStatuses = ["Pending", "In Progress", "Closed"];

      selectedStatus = allowedStatuses.contains(widget.workOrder!.status)
          ? widget.workOrder!.status
          : "Pending";
      final allowedTypes = ["Technical", "Other"];

      selectedType = allowedTypes.contains(widget.workOrder!.type)
          ? widget.workOrder!.type
          : "Technical";
    } else {
      // ADD MODE
      jobNoController.text = widget.autoGeneratedJobNo ?? "";
    }
  }

  Future<void> _loadEmployees() async {
    final data = await _employeeService.fetchEmployees();

    setState(() {
      _employees = data;

      // ðŸ”¥ If editing, pre-select assigned employees
      if (widget.workOrder != null) {
        _selectedEmployeeIds =
            widget.workOrder!.assignedEmployees.map((emp) => emp.id).toList();
      }
    });
  }

  Future<void> submit() async {
    if (!_formKey.currentState!.validate()) return;

    try {
      final now = DateTime.now().toIso8601String();

      final newWorkOrder = WorkOrder(
        id: widget.workOrder?.id ?? '',
        jobNo: jobNoController.text.trim(),
        Title: clientController.text.trim(),
        status: selectedStatus,
        description: descriptionController.text.trim(),
        location: locationController.text.trim(),
        type: selectedType,
        dateCreated: widget.workOrder?.dateCreated ?? now,
        dateModified: now,
      );

      if (widget.workOrder == null) {
        // ðŸ”¥ ADD MODE
        final createdOrder = await _service.addWorkOrder(newWorkOrder);

        if (!mounted) return;

        Navigator.pop(context, createdOrder);
      } else {
        // ðŸ”¥ UPDATE MODE
        await _service.updateWorkOrder(newWorkOrder);

        if (!mounted) return;

        Navigator.pop(context, "updated");
      }
    } catch (e) {
      if (!mounted) return;

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          widget.workOrder == null ? "New Work Order" : "Edit Work Order",
        ),
        actions: [
          if (widget.workOrder != null)
            IconButton(
              icon: const Icon(Icons.delete, color: Colors.red),
              onPressed: _confirmDelete,
            ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                TextFormField(
                  controller: jobNoController,
                  readOnly: true,
                  decoration: const InputDecoration(
                    labelText: "Job No",
                    hintText: "Auto-generated",
                    filled: true,
                  ),
                ),
                const SizedBox(height: 10),

                TextFormField(
                  controller: clientController,
                  decoration: const InputDecoration(labelText: "Title"),
                  validator: (value) => value!.isEmpty ? "Enter Title" : null,
                ),
                const SizedBox(height: 10),

                DropdownButtonFormField<String>(
                  value: selectedStatus,
                  items: const [
                    DropdownMenuItem(value: "Pending", child: Text("Pending")),
                    DropdownMenuItem(
                        value: "In Progress", child: Text("In Progress")),
                    DropdownMenuItem(value: "Closed", child: Text("Closed")),
                  ],
                  onChanged: (value) {
                    setState(() {
                      selectedStatus = value!;
                    });
                  },
                  decoration: const InputDecoration(labelText: "Status"),
                ),
                const SizedBox(height: 10),

                TextFormField(
                  controller: locationController,
                  decoration: const InputDecoration(labelText: "Location"),
                  validator: (value) =>
                      value!.isEmpty ? "Enter Location" : null,
                ),
                const SizedBox(height: 10),

                DropdownButtonFormField<String>(
                  value: selectedType,
                  items: const [
                    DropdownMenuItem(
                        value: "Technical", child: Text("Technical")),
                    DropdownMenuItem(value: "Other", child: Text("Other")),
                  ],
                  onChanged: (value) {
                    setState(() {
                      selectedType = value!;
                    });
                  },
                  decoration: const InputDecoration(labelText: "Type"),
                ),
                const SizedBox(height: 10),

                TextFormField(
                  controller: descriptionController,
                  decoration: const InputDecoration(labelText: "Description"),
                  maxLines: 3,
                ),

                // ðŸ”¥ NEW SECTION STARTS HERE
                const SizedBox(height: 25),

                const Text(
                  "Assign Employees",
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),

                const SizedBox(height: 10),

                _employees.isEmpty
                    ? const Center(child: CircularProgressIndicator())
                    : Column(
                        children: _employees.map((employee) {
                          final isSelected =
                              _selectedEmployeeIds.contains(employee.id);

                          return CheckboxListTile(
                            value: isSelected,
                            title: Text(employee.fullName),
                            subtitle: Text(employee.shiftType),
                            controlAffinity: ListTileControlAffinity.leading,
                            contentPadding: EdgeInsets.zero,
                            onChanged: (value) {
                              setState(() {
                                if (value == true) {
                                  _selectedEmployeeIds.add(employee.id);
                                } else {
                                  _selectedEmployeeIds.remove(employee.id);
                                }
                              });
                            },
                          );
                        }).toList(),
                      ),

                const SizedBox(height: 25),

                ElevatedButton(
                  onPressed: submit,
                  child: Text(
                    widget.workOrder == null
                        ? "Add Work Order"
                        : "Save Changes",
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _confirmDelete() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text("Delete Work Order"),
        content: const Text(
          "Are you sure you want to delete this work order?",
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text("Cancel"),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text(
              "Delete",
              style: TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );

    if (confirm == true && widget.workOrder != null) {
      await _service.deleteWorkOrder(widget.workOrder!.id);

      if (!mounted) return;

      Navigator.pop(context, "deleted"); // ðŸ”¥ VERY IMPORTANT
    }
  }

  @override
  void dispose() {
    jobNoController.dispose();
    clientController.dispose();
    descriptionController.dispose();
    locationController.dispose();
    super.dispose();
  }
}
